<rosieArtifact title="Amara's Quest - The Sunstone Fragment">
<rosieCreate file="index.html">
<![CDATA[
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Amara's Quest - The Sunstone Fragment</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; display: flex; justify-content: center; align-items: center; height: 100vh; }
        canvas { display: block; }
        #loadingScreen {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: #1a052a;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #f0e0ff;
            font-family: 'Arial', sans-serif;
            z-index: 100;
        }
        #loadingText {
            font-size: 24px;
            margin-bottom: 20px;
        }
        #progressBarContainer {
            width: 300px;
            height: 20px;
            background-color: #4a235a;
            border-radius: 10px;
            overflow: hidden;
        }
        #progressBar {
            width: 0%;
            height: 100%;
            background-color: #c39bd3;
            transition: width 0.3s ease-out;
        }
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-family: Arial, sans-serif;
            font-size: 16px;
            background-color: rgba(0,0,0,0.7);
            padding: 10px 15px;
            border-radius: 5px;
            text-align: center;
        }
    </style>
    <script type="importmap">
    {
        "imports": {
            "three": "https://esm.sh/three@0.160.0?dev",
            "three/": "https://esm.sh/three@0.160.0&dev/",
            "rosieControls": "./rosieControls.js", 
            "tween.js": "https://esm.sh/@tweenjs/tween.js@21.0.0"
        }
    }
    </script>
</head>
<body>
    <div id="loadingScreen">
        <div id="loadingText">Amara's Quest is Weaving...</div>
        <div id="progressBarContainer">
            <div id="progressBar"></div>
        </div>
    </div>
    <div id="instructions">
        WASD to Move | Space to Jump | Mouse to Orbit Camera | F to Play Kora Song
    </div>
    <script type="module" src="main.js"></script>
    <script src="https://storage.googleapis.com/rosebud_staticfiles/ScriptsLoader-Universal.js"></script>
    <script src="https://storage.googleapis.com/rosebud_staticfiles/ChatManager.js"></script>
    <script src="https://storage.googleapis.com/rosebud_staticfiles/ImageGenerator.js"></script>
    <script src="https://storage.googleapis.com/rosebud_staticfiles/ProgressLogger.js"></script>
    <script src="https://storage.googleapis.com/rosebud_staticfiles/OGP.js"></script>
</body>
</html>
]]>
</rosieCreate>
<rosieCreate file="main.js">
<![CDATA[
import * as THREE from 'three';
import { Game } from './game.js';

function showLoadingProgress(progress) {
    const progressBar = document.getElementById('progressBar');
    if (progressBar) {
        progressBar.style.width = progress * 100 + '%';
    }
}

function hideLoadingScreen() {
    const loadingScreen = document.getElementById('loadingScreen');
    if (loadingScreen) {
        loadingScreen.style.opacity = '0';
        setTimeout(() => loadingScreen.style.display = 'none', 500); // Fade out
    }
}

function init() {
    showLoadingProgress(0.1); // Initial progress

    const container = document.body;
    const game = new Game(container, showLoadingProgress);

    showLoadingProgress(0.8); // Progress after game setup

    function animate(time) {
        requestAnimationFrame(animate);
        game.update(time);
        game.render();
    }

    // Simulate asset loading / setup completion
    setTimeout(() => {
        showLoadingProgress(1);
        setTimeout(() => {
            hideLoadingScreen();
            animate(0); // Start game loop
        }, 300);
    }, 500);
}

// Ensure rosieControls.js is treated as a module by the browser.
// This is a bit of a conceptual placeholder for how modules are resolved.
// In a real scenario with import maps, the path "rosieControls" would be resolved correctly.
const rosieControlsModule = await import('rosieControls');

if (rosieControlsModule.PlayerController) {
    init();
} else {
    console.error("Failed to load rosieControls.js. Game cannot start.");
    const loadingText = document.getElementById('loadingText');
    if (loadingText) loadingText.textContent = "Error loading controls. Please refresh.";
}
]]>
</rosieCreate>
<rosieCreate file="game.js">
<![CDATA[
import * as THREE from 'three';
import TWEEN from 'tween.js';
import { PlayerController, ThirdPersonCameraController } from 'rosieControls';
import { Player } from './player.js';
import { World } from './world.js';
import { SpiritWisp } from './enemy.js';
import { KoraAttackVFX } from './vfx.js';

export class Game {
    constructor(container, updateLoadingProgress) {
        this.container = container;
        this.updateLoadingProgress = updateLoadingProgress;
        this.initScene();
        this.initPlayerAndControls();
        this.initWorld();
        this.initEnemies();
        this.initVFX();
        
        this.clock = new THREE.Clock();
        this.bindEventListeners();
        this.updateLoadingProgress(0.6); // After core initializations
    }

    initScene() {
        this.scene = new THREE.Scene();
        this.scene.fog = new THREE.Fog(0x532857, 20, 60); // Deep purple fog

        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        this.renderer.setClearColor(0x1a052a); // Dark twilight purple
        this.container.appendChild(this.renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xcc88ff, 0.8); // Lavender ambient
        this.scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffaa88, 2.5); // Warm sunset/sunrise glow
        dirLight.position.set(15, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 100;
        dirLight.shadow.camera.left = -30;
        dirLight.shadow.camera.right = 30;
        dirLight.shadow.camera.top = 30;
        dirLight.shadow.camera.bottom = -30;
        this.scene.add(dirLight);
        
        // Skybox
        const skyGeo = new THREE.SphereGeometry(100, 32, 15);
        const skyMat = new THREE.MeshBasicMaterial({
            map: this.createGradientTexture(),
            side: THREE.BackSide,
            fog: false
        });
        const sky = new THREE.Mesh(skyGeo, skyMat);
        this.scene.add(sky);
    }

    createGradientTexture() {
        const size = 512;
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const context = canvas.getContext('2d');
        const gradient = context.createLinearGradient(0, 0, 0, size);
        gradient.addColorStop(0, '#150e25'); // Dark purple zenith
        gradient.addColorStop(0.4, '#351558'); // Mid purple
        gradient.addColorStop(0.6, '#753a88'); // Lighter purple
        gradient.addColorStop(1, '#cc88ff'); // Lavender horizon
        context.fillStyle = gradient;
        context.fillRect(0, 0, size, size);
        return new THREE.CanvasTexture(canvas);
    }

    initPlayerAndControls() {
        this.player = new Player(this.scene);
        this.scene.add(this.player.model);
        this.updateLoadingProgress(0.3);

        this.playerController = new PlayerController(this.player.model, {
            moveSpeed: 6,
            jumpForce: 12,
            gravity: 30,
            groundLevel: this.player.groundOffset 
        });

        this.thirdPersonController = new ThirdPersonCameraController(this.camera, this.player.model, this.renderer.domElement, {
            distance: 6,
            height: 2.5,
            rotationSpeed: 0.005
        });
        this.updateLoadingProgress(0.4);
    }

    initWorld() {
        this.world = new World(this.scene);
        this.scene.add(this.world.group);
        this.sunstoneFragment = this.world.sunstoneFragment; // Keep a reference
        this.updateLoadingProgress(0.5);
    }

    initEnemies() {
        this.enemies = [];
        const wisp = new SpiritWisp(this.scene, new THREE.Vector3(5, 2.5, -8));
        this.enemies.push(wisp);
        this.scene.add(wisp.model);
    }

    initVFX() {
        this.koraAttackVFX = new KoraAttackVFX(this.scene);
    }

    bindEventListeners() {
        window.addEventListener('resize', this.onWindowResize.bind(this), false);
        window.addEventListener('keydown', this.onKeyDown.bind(this), false);
    }

    onWindowResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
    }

    onKeyDown(event) {
        if (event.code === 'KeyF') {
            if (this.player.canAttack()) {
                this.player.performKoraAttack( (attackPosition, attackDirection) => {
                    this.koraAttackVFX.play(attackPosition, attackDirection);
                    this.checkKoraAttackHits(attackPosition, attackDirection);
                });
            }
        }
    }
    
    checkKoraAttackHits(attackOrigin, attackDirection) {
        const raycaster = new THREE.Raycaster(attackOrigin, attackDirection.normalize(), 0, 10); // Max range of 10
        
        this.enemies.forEach((enemy, index) => {
            if (!enemy.isDefeated) {
                const intersects = raycaster.intersectObject(enemy.model, true);
                if (intersects.length > 0 && intersects[0].distance < 10) {
                    enemy.defeat();
                    // Could add score or other effects here
                }
            }
        });
    }


    checkSunstoneCollection() {
        if (this.sunstoneFragment && !this.sunstoneFragment.collected) {
            const distanceToFragment = this.player.model.position.distanceTo(this.sunstoneFragment.position);
            if (distanceToFragment < 1.5) { // Collection radius
                this.world.collectSunstoneFragment();
                // Simple feedback:
                const collectionMessage = document.createElement('div');
                collectionMessage.textContent = "Sunstone Fragment Recovered!";
                collectionMessage.style.cssText = `
                    position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
                    padding: 15px 25px; background-color: rgba(100, 50, 150, 0.85); color: white;
                    border-radius: 10px; font-size: 20px; font-family: Arial, sans-serif;
                    box-shadow: 0 0 15px rgba(200, 150, 255, 0.7); z-index: 1000;
                    animation: fadeOutMessage 3s forwards;
                `;
                document.body.appendChild(collectionMessage);
                
                const styleSheet = document.styleSheets[0];
                styleSheet.insertRule(`
                    @keyframes fadeOutMessage {
                        0% { opacity: 1; transform: translateX(-50%) translateY(0); }
                        80% { opacity: 1; transform: translateX(-50%) translateY(0); }
                        100% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
                    }
                `, styleSheet.cssRules.length);

                setTimeout(() => {
                    document.body.removeChild(collectionMessage);
                }, 3000);
            }
        }
    }

    update(time) {
        const deltaTime = this.clock.getDelta();
        TWEEN.update(time);

        const cameraRotation = this.thirdPersonController.update();
        this.playerController.update(deltaTime, cameraRotation);
        this.player.update(deltaTime);

        if (this.world) {
            this.world.update(deltaTime);
        }
        this.enemies.forEach(enemy => enemy.update(deltaTime));
        this.koraAttackVFX.update(deltaTime);

        this.checkSunstoneCollection();
    }

    render() {
        this.renderer.render(this.scene, this.camera);
    }
}
]]>
</rosieCreate>
<rosieCreate file="player.js">
<![CDATA[
import * as THREE from 'three';
import TWEEN from 'tween.js';

export class Player {
    constructor(scene) {
        this.scene = scene;
        this.model = this.createModel();
        this.groundOffset = 0.8; // Half of player height (capsule height is 1.6)
        this.model.position.y = this.groundOffset;

        this.attackCooldown = 1000; // 1 second cooldown
        this.lastAttackTime = 0;
    }

    createModel() {
        const group = new THREE.Group();

        // Body (Capsule-like: Cylinder + two Spheres)
        const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x885522 }); // Rich brown
        const bodyRadius = 0.4;
        const bodyHeight = 0.8; 
        
        const torso = new THREE.Mesh(
            new THREE.CylinderGeometry(bodyRadius, bodyRadius, bodyHeight, 16),
            bodyMaterial
        );
        torso.castShadow = true;
        torso.receiveShadow = true;
        torso.position.y = bodyHeight / 2; // Centered on its own height
        group.add(torso);

        // Head
        const headMaterial = new THREE.MeshStandardMaterial({ color: 0x503010 }); // Darker brown
        const head = new THREE.Mesh(
            new THREE.SphereGeometry(bodyRadius * 0.8, 16, 16),
            headMaterial
        );
        head.position.y = bodyHeight + (bodyRadius * 0.8) * 0.9; // Position on top of torso
        head.castShadow = true;
        group.add(head);

        // Kora (simplified as a decorated staff/instrument)
        const koraMaterial = new THREE.MeshStandardMaterial({ color: 0xdaa520, emissive: 0x332205 }); // Golden with slight glow
        const koraStick = new THREE.Mesh(
            new THREE.CylinderGeometry(0.05, 0.05, 1.2, 8),
            koraMaterial
        );
        koraStick.position.set(bodyRadius * 0.7, bodyHeight * 0.6, bodyRadius * 0.5); // Held at an angle
        koraStick.rotation.z = Math.PI / 8;
        koraStick.rotation.x = Math.PI / 10;
        koraStick.castShadow = true;
        group.add(koraStick);
        
        const koraResonator = new THREE.Mesh(
             new THREE.SphereGeometry(0.2, 8, 6),
             new THREE.MeshStandardMaterial({ color: 0xCD853F, emissive: 0x221103 }) // Peru color
        );
        koraResonator.position.y = -0.4; // Lower part of the stick
        koraStick.add(koraResonator); // Attach to stick
        
        // Total player model height is roughly bodyHeight + head diameter
        // Player model's origin is at its feet.
        group.position.set(0, this.groundOffset, 0); 
        return group;
    }

    canAttack() {
        return Date.now() - this.lastAttackTime > this.attackCooldown;
    }

    performKoraAttack(onAttackVFXCallback) {
        this.lastAttackTime = Date.now();

        // Simple animation for kora
        const kora = this.model.children.find(child => child.geometry.type === "CylinderGeometry" && child.material.color.getHex() === 0xdaa520);
        if (kora) {
            const originalRotation = kora.rotation.clone();
            new TWEEN.Tween(kora.rotation)
                .to({ z: originalRotation.z - Math.PI / 6 }, 150)
                .easing(TWEEN.Easing.Quadratic.Out)
                .yoyo(true)
                .repeat(1)
                .start();
        }

        // Determine attack position and direction
        const attackOrigin = new THREE.Vector3();
        this.model.getWorldPosition(attackOrigin);
        attackOrigin.y += 1.2; // Approximate kora height

        const attackDirection = new THREE.Vector3();
        this.model.getWorldDirection(attackDirection);
        // Player model faces -Z, so negate the direction for forward
        attackDirection.negate(); 

        if (onAttackVFXCallback) {
            onAttackVFXCallback(attackOrigin, attackDirection);
        }
    }

    update(deltaTime) {
        // Player model updates (e.g., animations) can go here
    }
}
]]>
</rosieCreate>
<rosieCreate file="world.js">
<![CDATA[
import * as THREE from 'three';
import TWEEN from 'tween.js';

export class World {
    constructor(scene) {
        this.scene = scene;
        this.group = new THREE.Group();
        this.createGround();
        this.createBaobabTrees();
        this.createFlora();
        this.createSunstoneFragment();
    }

    createGround() {
        const groundGeometry = new THREE.PlaneGeometry(100, 100, 50, 50);
        const groundMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x556B2F, // Dark Olive Green
            roughness: 0.9,
            metalness: 0.1 
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        this.group.add(ground);

        // Add some undulation to the ground
        const { position } = groundGeometry.attributes;
        for (let i = 0; i < position.count; i++) {
            const y = position.getY(i);
            const x = position.getX(i);
            const noise = Math.sin(x * 0.1) * Math.cos(y * 0.1) * 1.5;
            position.setZ(i, position.getZ(i) + noise); // Using Z for height as plane is XY before rotation
        }
        position.needsUpdate = true;
        groundGeometry.computeVertexNormals();
    }

    createBaobabTrees() {
        const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B7355, roughness: 0.8 }); // Dusty brown
        const foliageMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22, roughness: 0.7 }); // Forest green

        const createBaobab = (posX, posZ, scale) => {
            const tree = new THREE.Group();

            // Trunk - wider at base, tapers
            const trunkHeight = 6 * scale;
            const baseRadius = 1.5 * scale;
            const topRadius = 1 * scale;
            const trunkGeometry = new THREE.CylinderGeometry(topRadius, baseRadius, trunkHeight, 12);
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = trunkHeight / 2;
            trunk.castShadow = true;
            tree.add(trunk);

            // Foliage - cluster of spheres
            const numFoliageBlobs = 5 + Math.floor(Math.random() * 3);
            for (let i = 0; i < numFoliageBlobs; i++) {
                const foliageRadius = (1.5 + Math.random() * 1) * scale;
                const foliageGeometry = new THREE.SphereGeometry(foliageRadius, 8, 6);
                const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
                
                const offsetX = (Math.random() - 0.5) * topRadius * 2.5;
                const offsetZ = (Math.random() - 0.5) * topRadius * 2.5;
                const offsetY = trunkHeight + (Math.random() - 0.2) * foliageRadius * 0.8;
                
                foliage.position.set(offsetX, offsetY - trunkHeight/2, offsetZ); // Relative to trunk top
                foliage.castShadow = true;
                trunk.add(foliage); // Add to trunk so it moves with trunk's base position
            }
            
            tree.position.set(posX, 0, posZ); // Set base position of tree
            this.group.add(tree);
        };

        createBaobab(-10, -15, 1.2);
        createBaobab(12, -10, 1.0);
        createBaobab(5, 18, 1.5);
        createBaobab(-15, 8, 0.9);
        createBaobab(20, 5, 1.3);
    }
    
    createFlora() {
        const bushMaterial = new THREE.MeshStandardMaterial({ color: 0x556B2F, roughness: 0.8 }); // Dark olive
        const flowerMaterial = new THREE.MeshStandardMaterial({ color: 0xFF69B4, emissive: 0x330011 }); // Hot pink glowing flowers

        for (let i = 0; i < 30; i++) {
            const group = new THREE.Group();
            const radius = Math.random() * 0.3 + 0.2;
            const height = Math.random() * 0.5 + 0.3;
            
            const bushGeom = new THREE.IcosahedronGeometry(radius, 0);
            const bush = new THREE.Mesh(bushGeom, bushMaterial);
            bush.scale.y = height / (radius * 2); // Make it more bush-like
            bush.position.y = height / 2;
            bush.castShadow = true;
            group.add(bush);

            // Add some glowing flowers
            if (Math.random() < 0.3) {
                for(let j=0; j<3; j++) {
                    const flowerGeom = new THREE.SphereGeometry(0.05, 5, 5);
                    const flower = new THREE.Mesh(flowerGeom, flowerMaterial);
                    flower.position.set(
                        (Math.random() - 0.5) * radius * 1.5,
                        height + Math.random() * 0.1,
                        (Math.random() - 0.5) * radius * 1.5
                    );
                    group.add(flower);
                }
            }
            
            const posX = (Math.random() - 0.5) * 60;
            const posZ = (Math.random() - 0.5) * 60;
            // Basic collision check with trees (very simplified)
            if (Math.abs(posX) > 3 && Math.abs(posZ) > 3) { // Avoid center
                 group.position.set(posX, 0, posZ);
                 this.group.add(group);
            }
        }
    }

    createSunstoneFragment() {
        const fragmentGeometry = new THREE.IcosahedronGeometry(0.5, 0);
        const fragmentMaterial = new THREE.MeshStandardMaterial({
            color: 0xFFD700, // Gold
            emissive: 0xccaa00,
            emissiveIntensity: 0.8,
            metalness: 0.8,
            roughness: 0.2,
            transparent: true,
            opacity: 0.9
        });
        this.sunstoneFragment = new THREE.Mesh(fragmentGeometry, fragmentMaterial);
        this.sunstoneFragment.position.set(8, 3, 12); // Place it somewhere interesting
        this.sunstoneFragment.castShadow = true;
        this.sunstoneFragment.collected = false;

        // Add a point light to make it glow more
        const light = new THREE.PointLight(0xFFD700, 5, 5);
        light.position.copy(this.sunstoneFragment.position);
        this.sunstoneFragment.add(light); // Attach light to fragment
        
        this.group.add(this.sunstoneFragment);
    }
    
    collectSunstoneFragment() {
        if (this.sunstoneFragment && !this.sunstoneFragment.collected) {
            this.sunstoneFragment.collected = true;
            // Visual feedback for collection
            new TWEEN.Tween(this.sunstoneFragment.scale)
                .to({ x: 0.01, y: 0.01, z: 0.01 }, 500)
                .easing(TWEEN.Easing.Back.In)
                .onComplete(() => {
                    this.sunstoneFragment.visible = false;
                    // Remove light too
                    const pointLight = this.sunstoneFragment.children.find(c => c.isPointLight);
                    if(pointLight) pointLight.intensity = 0;
                })
                .start();

            // Sound effect or particle burst could be added here in future
        }
    }


    update(deltaTime) {
        if (this.sunstoneFragment && !this.sunstoneFragment.collected) {
            this.sunstoneFragment.rotation.y += 0.5 * deltaTime;
            this.sunstoneFragment.rotation.x += 0.3 * deltaTime;
            // Bobbing motion
            this.sunstoneFragment.position.y = 3 + Math.sin(Date.now() * 0.001) * 0.25;
        }
    }
}
]]>
</rosieCreate>
<rosieCreate file="enemy.js">
<![CDATA[
import * as THREE from 'three';
import TWEEN from 'tween.js';

export class SpiritWisp {
    constructor(scene, position = new THREE.Vector3(0, 2, -5)) {
        this.scene = scene;
        this.model = this.createModel();
        this.model.position.copy(position);
        this.isDefeated = false;
        this.initialY = position.y;
    }

    createModel() {
        const group = new THREE.Group();

        const coreMaterial = new THREE.MeshStandardMaterial({
            color: 0xADD8E6, // Light blue
            emissive: 0x87CEEB, // Sky blue emissive
            transparent: true,
            opacity: 0.7,
            roughness: 0.3,
            metalness: 0.2,
        });
        const coreGeom = new THREE.SphereGeometry(0.4, 16, 16);
        const core = new THREE.Mesh(coreGeom, coreMaterial);
        group.add(core);

        const particleMaterial = new THREE.PointsMaterial({
            color: 0xFFFFFF,
            size: 0.1,
            transparent: true,
            opacity: 0.5,
            blending: THREE.AdditiveBlending,
            sizeAttenuation: true,
        });
        
        const particleCount = 50;
        const positions = new Float32Array(particleCount * 3);
        for (let i = 0; i < particleCount; i++) {
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos((Math.random() * 2) - 1);
            const radius = 0.4 + Math.random() * 0.3;
            positions[i * 3] = Math.sin(phi) * Math.cos(theta) * radius;
            positions[i * 3 + 1] = Math.sin(phi) * Math.sin(theta) * radius;
            positions[i * 3 + 2] = Math.cos(phi) * radius;
        }
        const particleGeom = new THREE.BufferGeometry();
        particleGeom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        this.particles = new THREE.Points(particleGeom, particleMaterial);
        group.add(this.particles);
        
        // Point light for glow
        this.light = new THREE.PointLight(0xADD8E6, 2, 3);
        group.add(this.light);

        group.castShadow = false; // Wisps are ethereal
        return group;
    }

    defeat() {
        if (this.isDefeated) return;
        this.isDefeated = true;
        
        // Visual feedback for defeat
        new TWEEN.Tween(this.model.scale)
            .to({ x: 0.01, y: 0.01, z: 0.01 }, 300)
            .easing(TWEEN.Easing.Exponential.In)
            .onComplete(() => {
                this.model.visible = false;
                // Optionally remove from scene: this.scene.remove(this.model);
            })
            .start();
        
        new TWEEN.Tween(this.light)
            .to({ intensity: 0 }, 300)
            .start();
    }

    update(deltaTime) {
        if (this.isDefeated) return;

        // Bobbing motion
        this.model.position.y = this.initialY + Math.sin(Date.now() * 0.002) * 0.3;
        
        // Particle rotation
        if(this.particles) {
            this.particles.rotation.x += 0.5 * deltaTime;
            this.particles.rotation.y += 0.3 * deltaTime;
        }
    }
}
]]>
</rosieCreate>
<rosieCreate file="vfx.js">
<![CDATA[
import * as THREE from 'three';
import TWEEN from 'tween.js';

export class KoraAttackVFX {
    constructor(scene) {
        this.scene = scene;
        this.particles = [];
        this.maxParticles = 20; // Pool size
        this.particleMaterial = new THREE.MeshBasicMaterial({
            color: 0xFFFF00, // Bright yellow
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending,
        });
        this.particleGeometry = new THREE.SphereGeometry(0.1, 6, 6);

        for (let i = 0; i < this.maxParticles; i++) {
            const particle = new THREE.Mesh(this.particleGeometry, this.particleMaterial.clone());
            particle.visible = false;
            this.scene.add(particle);
            this.particles.push(particle);
        }
    }

    play(origin, direction) {
        const particle = this.getAvailableParticle();
        if (!particle) return;

        particle.visible = true;
        particle.position.copy(origin);
        particle.scale.set(1,1,1); // Reset scale
        particle.material.opacity = 0.8;


        const targetPosition = new THREE.Vector3().copy(origin).add(direction.multiplyScalar(8)); // Travel 8 units

        new TWEEN.Tween(particle.position)
            .to({ x: targetPosition.x, y: targetPosition.y, z: targetPosition.z }, 400) // Duration of flight
            .easing(TWEEN.Easing.Quadratic.Out)
            .onComplete(() => {
                // Start fade out animation
                new TWEEN.Tween(particle.material)
                    .to({ opacity: 0 }, 200)
                    .onComplete(() => {
                        particle.visible = false;
                    })
                    .start();
                 new TWEEN.Tween(particle.scale)
                    .to({ x: 2, y: 2, z: 2 }, 200) // Expand slightly on impact/fade
                    .start();
            })
            .start();
    }

    getAvailableParticle() {
        for (let p of this.particles) {
            if (!p.visible) return p;
        }
        // If all are active, could create more or just skip (for now, skip)
        return null; 
    }

    update(deltaTime) {
        // TWEEN handles individual particle updates after they are launched
    }
}
]]>
</rosieCreate>
</rosieArtifact>
