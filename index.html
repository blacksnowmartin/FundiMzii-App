<rosieArtifact title="Amara's Quest - The Sunstone Fragment">
<rosieCreate file="index.html">
<![CDATA[
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Amara's Quest - The Sunstone Fragment</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; display: flex; justify-content: center; align-items: center; height: 100vh; }
        canvas { display: block; }
        #loadingScreen {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: #1a052a;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #f0e0ff;
            font-family: 'Arial', sans-serif;
            z-index: 100;
        }
        #loadingText {
            font-size: 24px;
            margin-bottom: 20px;
        }
        #progressBarContainer {
            width: 300px;
            height: 20px;
            background-color: #4a235a;
            border-radius: 10px;
            overflow: hidden;
        }
        #progressBar {
            width: 0%;
            height: 100%;
            background-color: #c39bd3;
            transition: width 0.3s ease-out;
        }
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-family: Arial, sans-serif;
            font-size: 14px;
            background-color: rgba(0,0,0,0.7);
            padding: 10px 15px;
            border-radius: 5px;
            text-align: center;
        }
    </style>
    <script type="importmap">
    {
        "imports": {
            "three": "https://esm.sh/three@0.160.0?dev",
            "three/": "https://esm.sh/three@0.160.0&dev/",
            "rosieControls": "./rosieControls.js", 
            "tween.js": "https://esm.sh/@tweenjs/tween.js@21.0.0"
        }
    }
    </script>
</head>
<body>
    <div id="loadingScreen">
        <div id="loadingText">Amara's Quest is Weaving...</div>
        <div id="progressBarContainer">
            <div id="progressBar"></div>
        </div>
    </div>
    <div id="instructions">
        WASD to Move | Space to Jump | Mouse to Orbit Camera | F to Attack | Collect all 5 Sunstone Fragments to Win!
    </div>
    <script type="module" src="main.js"></script>
    <script src="https://storage.googleapis.com/rosebud_staticfiles/ScriptsLoader-Universal.js"></script>
    <script src="https://storage.googleapis.com/rosebud_staticfiles/ChatManager.js"></script>
    <script src="https://storage.googleapis.com/rosebud_staticfiles/ImageGenerator.js"></script>
    <script src="https://storage.googleapis.com/rosebud_staticfiles/ProgressLogger.js"></script>
    <script src="https://storage.googleapis.com/rosebud_staticfiles/OGP.js"></script>
</body>
</html>
]]>
</rosieCreate>
<rosieCreate file="main.js">
<![CDATA[
import * as THREE from 'three';
import { Game } from './game.js';

function showLoadingProgress(progress) {
    const progressBar = document.getElementById('progressBar');
    if (progressBar) {
        progressBar.style.width = progress * 100 + '%';
    }
}

function hideLoadingScreen() {
    const loadingScreen = document.getElementById('loadingScreen');
    if (loadingScreen) {
        loadingScreen.style.opacity = '0';
        setTimeout(() => loadingScreen.style.display = 'none', 500); // Fade out
    }
}

function init() {
    showLoadingProgress(0.1); // Initial progress

    const container = document.body;
    const game = new Game(container, showLoadingProgress);

    showLoadingProgress(0.8); // Progress after game setup

    function animate(time) {
        requestAnimationFrame(animate);
        if (!game.isGameOver) {
            game.update(time);
        }
        game.render();
    }

    // Simulate asset loading / setup completion
    setTimeout(() => {
        showLoadingProgress(1);
        setTimeout(() => {
            hideLoadingScreen();
            animate(0); // Start game loop
        }, 300);
    }, 500);
}

// Ensure rosieControls.js is treated as a module by the browser.
// This is a bit of a conceptual placeholder for how modules are resolved.
// In a real scenario with import maps, the path "rosieControls" would be resolved correctly.
const rosieControlsModule = await import('rosieControls');

if (rosieControlsModule.PlayerController) {
    init();
} else {
    console.error("Failed to load rosieControls.js. Game cannot start.");
    const loadingText = document.getElementById('loadingText');
    if (loadingText) loadingText.textContent = "Error loading controls. Please refresh.";
}
]]>
</rosieCreate>
<rosieCreate file="game.js">
<![CDATA[
import * as THREE from 'three';
import TWEEN from 'tween.js';
import { PlayerController, ThirdPersonCameraController } from 'rosieControls';
import { Player } from './player.js';
import { World } from './world.js';
import { SpiritWisp } from './enemy.js';
import { KoraAttackVFX } from './vfx.js';

export class Game {
    constructor(container, updateLoadingProgress) {
        this.container = container;
        this.updateLoadingProgress = updateLoadingProgress;
        this.initScene();
        this.initPlayerAndControls();
        this.initWorld();
        this.initEnemies();
        this.initVFX();
        this.initUI();
        
        this.clock = new THREE.Clock();
        this.bindEventListeners();
        this.updateLoadingProgress(0.6); // After core initializations
        this.score = 0;
    }

    initScene() {
        this.scene = new THREE.Scene();
        this.scene.fog = new THREE.Fog(0x532857, 20, 60); // Deep purple fog

        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        this.renderer.setClearColor(0x1a052a); // Dark twilight purple
        this.container.appendChild(this.renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xcc88ff, 0.8); // Lavender ambient
        this.scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffaa88, 2.5); // Warm sunset/sunrise glow
        dirLight.position.set(15, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 100;
        dirLight.shadow.camera.left = -30;
        dirLight.shadow.camera.right = 30;
        dirLight.shadow.camera.top = 30;
        dirLight.shadow.camera.bottom = -30;
        this.scene.add(dirLight);
        
        // Skybox
        const skyGeo = new THREE.SphereGeometry(100, 32, 15);
        const skyMat = new THREE.MeshBasicMaterial({
            map: this.createGradientTexture(),
            side: THREE.BackSide,
            fog: false
        });
        const sky = new THREE.Mesh(skyGeo, skyMat);
        this.scene.add(sky);
    }

    createGradientTexture() {
        const size = 512;
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const context = canvas.getContext('2d');
        const gradient = context.createLinearGradient(0, 0, 0, size);
        gradient.addColorStop(0, '#150e25'); // Dark purple zenith
        gradient.addColorStop(0.4, '#351558'); // Mid purple
        gradient.addColorStop(0.6, '#753a88'); // Lighter purple
        gradient.addColorStop(1, '#cc88ff'); // Lavender horizon
        context.fillStyle = gradient;
        context.fillRect(0, 0, size, size);
        return new THREE.CanvasTexture(canvas);
    }

    initPlayerAndControls() {
        this.player = new Player(this.scene);
        this.scene.add(this.player.model);
        this.updateLoadingProgress(0.3);

        this.playerController = new PlayerController(this.player.model, {
            moveSpeed: 6,
            jumpForce: 12,
            gravity: 30,
            groundLevel: this.player.groundOffset 
        });

        this.thirdPersonController = new ThirdPersonCameraController(this.camera, this.player.model, this.renderer.domElement, {
            distance: 6,
            height: 2.5,
            rotationSpeed: 0.005
        });
        this.updateLoadingProgress(0.4);
    }

    initWorld() {
        this.world = new World(this.scene);
        this.scene.add(this.world.group);
        this.sunstoneFragments = this.world.sunstoneFragments; // Keep a reference
        this.updateLoadingProgress(0.5);
    }

    initEnemies() {
        this.enemies = [];
        const positions = [
            new THREE.Vector3(5, 2.5, -8),
            new THREE.Vector3(-10, 2.5, 5),
            new THREE.Vector3(15, 2.5, 10),
            new THREE.Vector3(-5, 2.5, -15),
            new THREE.Vector3(0, 2.5, 20)
        ];
        positions.forEach(pos => {
            const wisp = new SpiritWisp(this.scene, pos);
            this.enemies.push(wisp);
            this.scene.add(wisp.model);
        });
    }

    initVFX() {
        this.koraAttackVFX = new KoraAttackVFX(this.scene);
    }

    initUI() {
        this.healthBar = document.createElement('div');
        this.healthBar.style.cssText = `
            position: absolute; top: 10px; left: 10px; width: 200px; height: 20px;
            background-color: #333; border: 2px solid #fff; border-radius: 10px; overflow: hidden;
        `;
        this.healthFill = document.createElement('div');
        this.healthFill.style.cssText = `
            width: 100%; height: 100%; background-color: #f00; transition: width 0.3s;
        `;
        this.healthBar.appendChild(this.healthFill);
        document.body.appendChild(this.healthBar);

        this.scoreDisplay = document.createElement('div');
        this.scoreDisplay.style.cssText = `
            position: absolute; top: 10px; right: 10px; color: white; font-size: 24px; font-family: Arial;
        `;
        this.scoreDisplay.textContent = 'Score: 0';
        document.body.appendChild(this.scoreDisplay);
    }

    bindEventListeners() {
        window.addEventListener('resize', this.onWindowResize.bind(this), false);
        window.addEventListener('keydown', this.onKeyDown.bind(this), false);
    }

    onWindowResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
    }

    onKeyDown(event) {
        if (event.code === 'KeyF') {
            if (this.player.canAttack()) {
                this.player.performKoraAttack( (attackPosition, attackDirection) => {
                    this.koraAttackVFX.play(attackPosition, attackDirection);
                    this.checkKoraAttackHits(attackPosition, attackDirection);
                });
            }
        }
    }
    
    checkKoraAttackHits(attackOrigin, attackDirection) {
        const raycaster = new THREE.Raycaster(attackOrigin, attackDirection.normalize(), 0, 10); // Max range of 10
        
        this.enemies.forEach((enemy, index) => {
            if (!enemy.isDefeated) {
                const intersects = raycaster.intersectObject(enemy.model, true);
                if (intersects.length > 0 && intersects[0].distance < 10) {
                    enemy.takeDamage(25); // Deal damage instead of instant defeat
                    if (enemy.isDefeated) {
                        this.score += 100; // Score for defeating enemy
                    }
                }
            }
        });
    }


    checkSunstoneCollection() {
        this.sunstoneFragments.forEach(fragment => {
            if (!fragment.collected) {
                const distanceToFragment = this.player.model.position.distanceTo(fragment.position);
                if (distanceToFragment < 1.5) { // Collection radius
                    this.world.collectSunstoneFragment(fragment);
                    this.score += 50; // Score for collecting fragment
                    // Simple feedback:
                    const collectionMessage = document.createElement('div');
                    collectionMessage.textContent = "Sunstone Fragment Recovered!";
                    collectionMessage.style.cssText = `
                        position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
                        padding: 15px 25px; background-color: rgba(100, 50, 150, 0.85); color: white;
                        border-radius: 10px; font-size: 20px; font-family: Arial, sans-serif;
                        box-shadow: 0 0 15px rgba(200, 150, 255, 0.7); z-index: 1000;
                        animation: fadeOutMessage 3s forwards;
                    `;
                    document.body.appendChild(collectionMessage);
                    
                    const styleSheet = document.styleSheets[0];
                    styleSheet.insertRule(`
                        @keyframes fadeOutMessage {
                            0% { opacity: 1; transform: translateX(-50%) translateY(0); }
                            80% { opacity: 1; transform: translateX(-50%) translateY(0); }
                            100% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
                        }
                    `, styleSheet.cssRules.length);

                    setTimeout(() => {
                        document.body.removeChild(collectionMessage);
                    }, 3000);
                }
            }
        });
    }

    update(time) {
        const deltaTime = this.clock.getDelta();
        TWEEN.update(time);

        const cameraRotation = this.thirdPersonController.update();
        this.playerController.update(deltaTime, cameraRotation);
        this.player.update(deltaTime);

        if (this.world) {
            this.world.update(deltaTime);
        }
        this.enemies.forEach(enemy => enemy.update(deltaTime, this.player));
        this.koraAttackVFX.update(deltaTime);

        this.checkSunstoneCollection();

        // Update UI
        this.healthFill.style.width = (this.player.health / this.player.maxHealth) * 100 + '%';
        this.scoreDisplay.textContent = 'Score: ' + this.score;

        // Check game over
        if (!this.player.isAlive()) {
            this.gameOver();
        }

        // Check win condition
        if (this.world.collectedFragments === this.world.totalFragments) {
            this.winGame();
        }
    }

    render() {
        this.renderer.render(this.scene, this.camera);
    }

    gameOver() {
        // Stop the game loop or show game over screen
        const gameOverMessage = document.createElement('div');
        gameOverMessage.textContent = "Game Over! Final Score: " + this.score;
        gameOverMessage.style.cssText = `
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            padding: 20px 40px; background-color: rgba(0,0,0,0.8); color: white;
            border-radius: 10px; font-size: 32px; font-family: Arial; text-align: center;
            z-index: 2000;
        `;
        document.body.appendChild(gameOverMessage);
        // Stop animation
        this.isGameOver = true;
    }

    winGame() {
        const winMessage = document.createElement('div');
        winMessage.textContent = "You Win! All fragments collected. Score: " + this.score;
        winMessage.style.cssText = `
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            padding: 20px 40px; background-color: rgba(0,255,0,0.8); color: white;
            border-radius: 10px; font-size: 32px; font-family: Arial; text-align: center;
            z-index: 2000;
        `;
        document.body.appendChild(winMessage);
        this.isGameOver = true;
    }
}
]]>
</rosieCreate>
<rosieCreate file="player.js">
<![CDATA[
import * as THREE from 'three';
import TWEEN from 'tween.js';

export class Player {
    constructor(scene) {
        this.scene = scene;
        this.model = this.createModel();
        this.groundOffset = 0.8; // Half of player height (capsule height is 1.6)
        this.model.position.y = this.groundOffset;

        this.attackCooldown = 1000; // 1 second cooldown
        this.lastAttackTime = 0;
        this.health = 100;
        this.maxHealth = 100;
    }

    createModel() {
        const group = new THREE.Group();

        // Body (Capsule-like: Cylinder + two Spheres)
        const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x885522 }); // Rich brown
        const bodyRadius = 0.4;
        const bodyHeight = 0.8; 
        
        const torso = new THREE.Mesh(
            new THREE.CylinderGeometry(bodyRadius, bodyRadius, bodyHeight, 16),
            bodyMaterial
        );
        torso.castShadow = true;
        torso.receiveShadow = true;
        torso.position.y = bodyHeight / 2; // Centered on its own height
        group.add(torso);

        // Head
        const headMaterial = new THREE.MeshStandardMaterial({ color: 0x503010 }); // Darker brown
        const head = new THREE.Mesh(
            new THREE.SphereGeometry(bodyRadius * 0.8, 16, 16),
            headMaterial
        );
        head.position.y = bodyHeight + (bodyRadius * 0.8) * 0.9; // Position on top of torso
        head.castShadow = true;
        group.add(head);

        // Kora (simplified as a decorated staff/instrument)
        const koraMaterial = new THREE.MeshStandardMaterial({ color: 0xdaa520, emissive: 0x332205 }); // Golden with slight glow
        const koraStick = new THREE.Mesh(
            new THREE.CylinderGeometry(0.05, 0.05, 1.2, 8),
            koraMaterial
        );
        koraStick.position.set(bodyRadius * 0.7, bodyHeight * 0.6, bodyRadius * 0.5); // Held at an angle
        koraStick.rotation.z = Math.PI / 8;
        koraStick.rotation.x = Math.PI / 10;
        koraStick.castShadow = true;
        group.add(koraStick);
        
        const koraResonator = new THREE.Mesh(
             new THREE.SphereGeometry(0.2, 8, 6),
             new THREE.MeshStandardMaterial({ color: 0xCD853F, emissive: 0x221103 }) // Peru color
        );
        koraResonator.position.y = -0.4; // Lower part of the stick
        koraStick.add(koraResonator); // Attach to stick
        
        // Total player model height is roughly bodyHeight + head diameter
        // Player model's origin is at its feet.
        group.position.set(0, this.groundOffset, 0); 
        return group;
    }

    canAttack() {
        return Date.now() - this.lastAttackTime > this.attackCooldown;
    }

    performKoraAttack(onAttackVFXCallback) {
        this.lastAttackTime = Date.now();

        // Simple animation for kora
        const kora = this.model.children.find(child => child.geometry.type === "CylinderGeometry" && child.material.color.getHex() === 0xdaa520);
        if (kora) {
            const originalRotation = kora.rotation.clone();
            new TWEEN.Tween(kora.rotation)
                .to({ z: originalRotation.z - Math.PI / 6 }, 150)
                .easing(TWEEN.Easing.Quadratic.Out)
                .yoyo(true)
                .repeat(1)
                .start();
        }

        // Determine attack position and direction
        const attackOrigin = new THREE.Vector3();
        this.model.getWorldPosition(attackOrigin);
        attackOrigin.y += 1.2; // Approximate kora height

        const attackDirection = new THREE.Vector3();
        this.model.getWorldDirection(attackDirection);
        // Player model faces -Z, so negate the direction for forward
        attackDirection.negate(); 

        if (onAttackVFXCallback) {
            onAttackVFXCallback(attackOrigin, attackDirection);
        }
    }

    update(deltaTime) {
        // Player model updates (e.g., animations) can go here
    }

    takeDamage(amount) {
        this.health -= amount;
        if (this.health < 0) this.health = 0;
        // Could add visual feedback like flashing or sound
    }

    isAlive() {
        return this.health > 0;
    }
}
]]>
</rosieCreate>
<rosieCreate file="world.js">
<![CDATA[
import * as THREE from 'three';
import TWEEN from 'tween.js';

export class World {
    constructor(scene) {
        this.scene = scene;
        this.group = new THREE.Group();
        this.createGround();
        this.createBaobabTrees();
        this.createFlora();
        this.createSunstoneFragments();
        this.collectedFragments = 0;
        this.totalFragments = 5;
    }

    createGround() {
        const groundGeometry = new THREE.PlaneGeometry(100, 100, 50, 50);
        const groundMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x556B2F, // Dark Olive Green
            roughness: 0.9,
            metalness: 0.1 
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        this.group.add(ground);

        // Add some undulation to the ground
        const { position } = groundGeometry.attributes;
        for (let i = 0; i < position.count; i++) {
            const y = position.getY(i);
            const x = position.getX(i);
            const noise = Math.sin(x * 0.1) * Math.cos(y * 0.1) * 1.5;
            position.setZ(i, position.getZ(i) + noise); // Using Z for height as plane is XY before rotation
        }
        position.needsUpdate = true;
        groundGeometry.computeVertexNormals();
    }

    createBaobabTrees() {
        const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B7355, roughness: 0.8 }); // Dusty brown
        const foliageMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22, roughness: 0.7 }); // Forest green

        const createBaobab = (posX, posZ, scale) => {
            const tree = new THREE.Group();

            // Trunk - wider at base, tapers
            const trunkHeight = 6 * scale;
            const baseRadius = 1.5 * scale;
            const topRadius = 1 * scale;
            const trunkGeometry = new THREE.CylinderGeometry(topRadius, baseRadius, trunkHeight, 12);
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = trunkHeight / 2;
            trunk.castShadow = true;
            tree.add(trunk);

            // Foliage - cluster of spheres
            const numFoliageBlobs = 5 + Math.floor(Math.random() * 3);
            for (let i = 0; i < numFoliageBlobs; i++) {
                const foliageRadius = (1.5 + Math.random() * 1) * scale;
                const foliageGeometry = new THREE.SphereGeometry(foliageRadius, 8, 6);
                const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
                
                const offsetX = (Math.random() - 0.5) * topRadius * 2.5;
                const offsetZ = (Math.random() - 0.5) * topRadius * 2.5;
                const offsetY = trunkHeight + (Math.random() - 0.2) * foliageRadius * 0.8;
                
                foliage.position.set(offsetX, offsetY - trunkHeight/2, offsetZ); // Relative to trunk top
                foliage.castShadow = true;
                trunk.add(foliage); // Add to trunk so it moves with trunk's base position
            }
            
            tree.position.set(posX, 0, posZ); // Set base position of tree
            this.group.add(tree);
        };

        createBaobab(-10, -15, 1.2);
        createBaobab(12, -10, 1.0);
        createBaobab(5, 18, 1.5);
        createBaobab(-15, 8, 0.9);
        createBaobab(20, 5, 1.3);
    }
    
    createFlora() {
        const bushMaterial = new THREE.MeshStandardMaterial({ color: 0x556B2F, roughness: 0.8 }); // Dark olive
        const flowerMaterial = new THREE.MeshStandardMaterial({ color: 0xFF69B4, emissive: 0x330011 }); // Hot pink glowing flowers

        for (let i = 0; i < 30; i++) {
            const group = new THREE.Group();
            const radius = Math.random() * 0.3 + 0.2;
            const height = Math.random() * 0.5 + 0.3;
            
            const bushGeom = new THREE.IcosahedronGeometry(radius, 0);
            const bush = new THREE.Mesh(bushGeom, bushMaterial);
            bush.scale.y = height / (radius * 2); // Make it more bush-like
            bush.position.y = height / 2;
            bush.castShadow = true;
            group.add(bush);

            // Add some glowing flowers
            if (Math.random() < 0.3) {
                for(let j=0; j<3; j++) {
                    const flowerGeom = new THREE.SphereGeometry(0.05, 5, 5);
                    const flower = new THREE.Mesh(flowerGeom, flowerMaterial);
                    flower.position.set(
                        (Math.random() - 0.5) * radius * 1.5,
                        height + Math.random() * 0.1,
                        (Math.random() - 0.5) * radius * 1.5
                    );
                    group.add(flower);
                }
            }
            
            const posX = (Math.random() - 0.5) * 60;
            const posZ = (Math.random() - 0.5) * 60;
            // Basic collision check with trees (very simplified)
            if (Math.abs(posX) > 3 && Math.abs(posZ) > 3) { // Avoid center
                 group.position.set(posX, 0, posZ);
                 this.group.add(group);
            }
        }
    }

    createSunstoneFragments() {
        this.sunstoneFragments = [];
        const positions = [
            new THREE.Vector3(8, 3, 12),
            new THREE.Vector3(-12, 3, -8),
            new THREE.Vector3(20, 3, -5),
            new THREE.Vector3(-18, 3, 15),
            new THREE.Vector3(0, 3, -25)
        ];
        positions.forEach(pos => {
            const fragment = this.createSingleFragment();
            fragment.position.copy(pos);
            this.sunstoneFragments.push(fragment);
            this.group.add(fragment);
        });
    }

    createSingleFragment() {
        const fragmentGeometry = new THREE.IcosahedronGeometry(0.5, 0);
        const fragmentMaterial = new THREE.MeshStandardMaterial({
            color: 0xFFD700, // Gold
            emissive: 0xccaa00,
            emissiveIntensity: 0.8,
            metalness: 0.8,
            roughness: 0.2,
            transparent: true,
            opacity: 0.9
        });
        const fragment = new THREE.Mesh(fragmentGeometry, fragmentMaterial);
        fragment.castShadow = true;
        fragment.collected = false;

        // Add a point light to make it glow more
        const light = new THREE.PointLight(0xFFD700, 5, 5);
        light.position.copy(fragment.position);
        fragment.add(light); // Attach light to fragment
        
        return fragment;
    }
    
    collectSunstoneFragment(fragment) {
        if (fragment && !fragment.collected) {
            fragment.collected = true;
            this.collectedFragments++;
            // Visual feedback for collection
            new TWEEN.Tween(fragment.scale)
                .to({ x: 0.01, y: 0.01, z: 0.01 }, 500)
                .easing(TWEEN.Easing.Back.In)
                .onComplete(() => {
                    fragment.visible = false;
                    // Remove light too
                    const pointLight = fragment.children.find(c => c.isPointLight);
                    if(pointLight) pointLight.intensity = 0;
                })
                .start();

            // Sound effect or particle burst could be added here in future
        }
    }


    update(deltaTime) {
        this.sunstoneFragments.forEach(fragment => {
            if (!fragment.collected) {
                fragment.rotation.y += 0.5 * deltaTime;
                fragment.rotation.x += 0.3 * deltaTime;
                // Bobbing motion
                fragment.position.y = 3 + Math.sin(Date.now() * 0.001) * 0.25;
            }
        });
    }
}
]]>
</rosieCreate>
<rosieCreate file="enemy.js">
<![CDATA[
import * as THREE from 'three';
import TWEEN from 'tween.js';

export class SpiritWisp {
    constructor(scene, position = new THREE.Vector3(0, 2, -5)) {
        this.scene = scene;
        this.model = this.createModel();
        this.model.position.copy(position);
        this.isDefeated = false;
        this.initialY = position.y;
        this.health = 50;
        this.maxHealth = 50;
        this.attackRange = 1.5;
        this.attackCooldown = 2000; // 2 seconds
        this.lastAttackTime = 0;
        this.speed = 2;
    }

    createModel() {
        const group = new THREE.Group();

        const coreMaterial = new THREE.MeshStandardMaterial({
            color: 0xADD8E6, // Light blue
            emissive: 0x87CEEB, // Sky blue emissive
            transparent: true,
            opacity: 0.7,
            roughness: 0.3,
            metalness: 0.2,
        });
        const coreGeom = new THREE.SphereGeometry(0.4, 16, 16);
        const core = new THREE.Mesh(coreGeom, coreMaterial);
        group.add(core);

        const particleMaterial = new THREE.PointsMaterial({
            color: 0xFFFFFF,
            size: 0.1,
            transparent: true,
            opacity: 0.5,
            blending: THREE.AdditiveBlending,
            sizeAttenuation: true,
        });
        
        const particleCount = 50;
        const positions = new Float32Array(particleCount * 3);
        for (let i = 0; i < particleCount; i++) {
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos((Math.random() * 2) - 1);
            const radius = 0.4 + Math.random() * 0.3;
            positions[i * 3] = Math.sin(phi) * Math.cos(theta) * radius;
            positions[i * 3 + 1] = Math.sin(phi) * Math.sin(theta) * radius;
            positions[i * 3 + 2] = Math.cos(phi) * radius;
        }
        const particleGeom = new THREE.BufferGeometry();
        particleGeom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        this.particles = new THREE.Points(particleGeom, particleMaterial);
        group.add(this.particles);
        
        // Point light for glow
        this.light = new THREE.PointLight(0xADD8E6, 2, 3);
        group.add(this.light);

        group.castShadow = false; // Wisps are ethereal
        return group;
    }

    defeat() {
        if (this.isDefeated) return;
        this.isDefeated = true;
        
        // Visual feedback for defeat
        new TWEEN.Tween(this.model.scale)
            .to({ x: 0.01, y: 0.01, z: 0.01 }, 300)
            .easing(TWEEN.Easing.Exponential.In)
            .onComplete(() => {
                this.model.visible = false;
                // Optionally remove from scene: this.scene.remove(this.model);
            })
            .start();
        
        new TWEEN.Tween(this.light)
            .to({ intensity: 0 }, 300)
            .start();
    }

    takeDamage(amount) {
        this.health -= amount;
        if (this.health <= 0) {
            this.defeat();
        }
    }

    attack(player) {
        if (Date.now() - this.lastAttackTime > this.attackCooldown) {
            this.lastAttackTime = Date.now();
            player.takeDamage(10); // Deal 10 damage
            // Visual feedback for attack, e.g., flash
        }
    }

    update(deltaTime, player) {
        if (this.isDefeated) return;

        // Bobbing motion
        this.model.position.y = this.initialY + Math.sin(Date.now() * 0.002) * 0.3;
        
        // Particle rotation
        if(this.particles) {
            this.particles.rotation.x += 0.5 * deltaTime;
            this.particles.rotation.y += 0.3 * deltaTime;
        }

        // AI: Move towards player if within range
        const distance = this.model.position.distanceTo(player.model.position);
        if (distance < 10) { // Detection range
            const direction = new THREE.Vector3().subVectors(player.model.position, this.model.position).normalize();
            this.model.position.add(direction.multiplyScalar(this.speed * deltaTime));
            this.model.position.y = this.initialY; // Keep on ground
        }

        // Attack if close
        if (distance < this.attackRange) {
            this.attack(player);
        }
    }
}
]]>
</rosieCreate>
<rosieCreate file="vfx.js">
<![CDATA[
import * as THREE from 'three';
import TWEEN from 'tween.js';

export class KoraAttackVFX {
    constructor(scene) {
        this.scene = scene;
        this.particles = [];
        this.maxParticles = 20; // Pool size
        this.particleMaterial = new THREE.MeshBasicMaterial({
            color: 0xFFFF00, // Bright yellow
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending,
        });
        this.particleGeometry = new THREE.SphereGeometry(0.1, 6, 6);

        for (let i = 0; i < this.maxParticles; i++) {
            const particle = new THREE.Mesh(this.particleGeometry, this.particleMaterial.clone());
            particle.visible = false;
            this.scene.add(particle);
            this.particles.push(particle);
        }
    }

    play(origin, direction) {
        const particle = this.getAvailableParticle();
        if (!particle) return;

        particle.visible = true;
        particle.position.copy(origin);
        particle.scale.set(1,1,1); // Reset scale
        particle.material.opacity = 0.8;


        const targetPosition = new THREE.Vector3().copy(origin).add(direction.multiplyScalar(8)); // Travel 8 units

        new TWEEN.Tween(particle.position)
            .to({ x: targetPosition.x, y: targetPosition.y, z: targetPosition.z }, 400) // Duration of flight
            .easing(TWEEN.Easing.Quadratic.Out)
            .onComplete(() => {
                // Start fade out animation
                new TWEEN.Tween(particle.material)
                    .to({ opacity: 0 }, 200)
                    .onComplete(() => {
                        particle.visible = false;
                    })
                    .start();
                 new TWEEN.Tween(particle.scale)
                    .to({ x: 2, y: 2, z: 2 }, 200) // Expand slightly on impact/fade
                    .start();
            })
            .start();
    }

    getAvailableParticle() {
        for (let p of this.particles) {
            if (!p.visible) return p;
        }
        // If all are active, could create more or just skip (for now, skip)
        return null; 
    }

    update(deltaTime) {
        // TWEEN handles individual particle updates after they are launched
    }
}
]]>
</rosieCreate>
</rosieArtifact>
